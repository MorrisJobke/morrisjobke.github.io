<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><title>Morris Jobke</title><link rel=stylesheet href=/css/pygment_trac.css?1609711377><link rel=alternate type=application/atom+xml title="Atom feed" href=/feed.xml><link rel=stylesheet href=/css/webfonts.css?1609711377><link rel=stylesheet href=/css/base.css?1609711377><meta property="og:title" content="Hadoop - NameNode, Checkpoint Node and Backup Node"><meta property="og:description" content="NameNode The NameNode stores the metadata of the HDFS. The state of HDFS is stored in a file called fsimage and is the base of the metadata. During the runtime modifications are just written to a log file called edits. On the next start-up of the NameNode the state is read from fsimage, the changes from edits are applied to that and the new state is written back to fsimage. After this edits is cleared and contains is now ready for new log entries."><meta property="og:type" content="article"><meta property="og:url" content="https://morrisjobke.de/2013/12/11/Hadoop-NameNode-and-siblings/"><meta property="article:published_time" content="2013-12-11T18:20:00+00:00"><meta property="article:modified_time" content="2013-12-11T18:20:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hadoop - NameNode, Checkpoint Node and Backup Node"><meta name=twitter:description content="NameNode The NameNode stores the metadata of the HDFS. The state of HDFS is stored in a file called fsimage and is the base of the metadata. During the runtime modifications are just written to a log file called edits. On the next start-up of the NameNode the state is read from fsimage, the changes from edits are applied to that and the new state is written back to fsimage. After this edits is cleared and contains is now ready for new log entries."><meta name=twitter:site content="@MorrisJobke"><meta itemprop=name content="Hadoop - NameNode, Checkpoint Node and Backup Node"><meta itemprop=description content="NameNode The NameNode stores the metadata of the HDFS. The state of HDFS is stored in a file called fsimage and is the base of the metadata. During the runtime modifications are just written to a log file called edits. On the next start-up of the NameNode the state is read from fsimage, the changes from edits are applied to that and the new state is written back to fsimage. After this edits is cleared and contains is now ready for new log entries."><meta itemprop=datePublished content="2013-12-11T18:20:00+00:00"><meta itemprop=dateModified content="2013-12-11T18:20:00+00:00"><meta itemprop=wordCount content="477"><meta itemprop=keywords content></head><body><div class=header><div class=container><span class=name>Morris<b>Jobke</b></span><ul class=menu><li><a href=/>Articles</a></wli> /<li><a href=/talks>Talks</a></li>/<li><a href=/links>Links</a></li><li class=item-right><a href=/feed.xml><svg width="20" height="20" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M576 1344q0 80-56 136t-136 56-136-56-56-136 56-136 136-56 136 56 56 136zm512 123q2 28-17 48-18 21-47 21H889q-25 0-43-16.5t-20-41.5q-22-229-184.5-391.5T250 902q-25-2-41.5-20T192 839V704q0-29 21-47 17-17 43-17h5q160 13 306 80.5T826 902q114 113 181.5 259t80.5 306zm512 2q2 27-18 47-18 20-46 20h-143q-26 0-44.5-17.5T1329 1476q-12-215-101-408.5t-231.5-336-336-231.5T252 398q-25-1-42.5-19.5T192 335V192q0-28 20-46 18-18 44-18h3q262 13 501.5 120T1186 542q187 186 294 425.5t120 501.5z" fill="#fff"/></svg></a></li><li class=item-right><a href=https://twitter.com/MorrisJobke><svg width="20" height="20" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5T1369.5 1125 1185 1335.5t-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5T285 1033q33 5 61 5 43 0 85-11-112-23-185.5-111.5T172 710v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5T884 653q-8-38-8-74 0-134 94.5-228.5T1199 256q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z" fill="#fff"/></svg></a></li><li class=item-right><a href=https://github.com/MorrisJobke><svg width="20" height="20" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1664 896q0 251-146.5 451.5T1139 1625q-27 5-39.5-7t-12.5-30v-211q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 89t.5 54q0 18-13 30t-40 7q-232-77-378.5-277.5T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z" fill="#fff"/></svg></a></li></ul></div></div><div class=container><h1>Hadoop - NameNode, Checkpoint Node and Backup Node <span class=meta>11 Dec 2013</span></h1><div id=post><h3 id=namenode>NameNode</h3><p>The NameNode stores the metadata of the HDFS. The state of HDFS is stored in a
file called <code>fsimage</code> and is the base of the metadata. During the runtime
modifications are just written to a log file called <code>edits</code>. On the next
start-up of the NameNode the state is read from <code>fsimage</code>, the changes from
<code>edits</code> are applied to that and the new state is written back to <code>fsimage</code>.
After this <code>edits</code> is cleared and contains is now ready for new log entries.</p><h3 id=checkpoint-node>Checkpoint Node</h3><p>A Checkpoint Node was introduced to solve the drawbacks of the NameNode. The
changes are just written to <code>edits</code> and not merged to <code>fsimage</code> during the
runtime. If the NameNode runs for a while <code>edits</code> gets huge and the next
startup will take even longer because more changes have to be applied to the
state to determine the last state of the metadata.</p><p>The Checkpoint Node fetches periodically <code>fsimage</code> and <code>edits</code> from the
NameNode and merges them. The resulting state is called checkpoint. After this
is uploads the result to the NameNode.</p><p>There was also a similiar type of node called &ldquo;Secondary Node&rdquo; but it doesn&rsquo;t
have the &ldquo;upload to NameNode&rdquo; feature. So the NameNode need to fetch the state
from the Secondary NameNode. It also was confussing because the name suggests
that the Secondary NameNode takes the request if the NameNode fails which
isn&rsquo;t the case.</p><h3 id=backup-node>Backup Node</h3><p>The Backup Node provides the same functionality as the Checkpoint Node, but is
synchronized with the NameNode. It doesn&rsquo;t need to fetch the changes
periodically because it receives a strem of file system edits. from the
NameNode. It holds the current state in-memory and just need to save this to
an image file to create a new checkpoint.</p><h4 id=sources>Sources</h4><ul><li><a href=https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html#Secondary_NameNode>NameNode, Secondary NameNode, CheckpointNode, Backup Node @ Hadoop Wiki</a></li><li><a href=http://stackoverflow.com/a/19975012>NameNode vs Secondary NameNode @ stackoverflow</a></li><li><a href=http://stackoverflow.com/a/10424902>Checkpoint Node, Backup Node @ stackoverflow</a></li><li><a href="https://issues.apache.org/jira/browse/HADOOP-4539?focusedCommentId=12674954&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12674954">Hadoop Bugtracker - Comment about introduction of Checkpoint and Backup Node</a></li></ul><h3 id=updates>Updates:</h3><p><strong>Comment by Moritz Becker (March 2017):</strong></p><blockquote><p>&ldquo;There was also a similiar type of node called ‚ÄúSecondary Node‚Äù but it doesn‚Äôt
have the ‚Äúupload to NameNode‚Äù feature. So the NameNode need to fetch the state
from the Secondary NameNode.&rdquo;</p><p>This appears to be wrong. The Secondary NameNode (SNN) does in fact (indirectly) upload the checkpoint to the NameNode (NN). Indirectly means that, once checkpointing is completed, the SNN issues a GET request to the NN to trigger a fetch of the checkpoint by the NN. However, a CheckpointNode (CN) does exactly the same. So there is no difference between the operations of SNN and CN. However, SNN was deprecated in favor of CN.</p><ul><li><a href=https://issues.apache.org/jira/browse/HADOOP-4539>https://issues.apache.org/jira/browse/HADOOP-4539</a></li><li><a href=https://github.com/apache/hadoop-hdfs/blob/HDFS-265/src/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java>https://github.com/apache/hadoop-hdfs/blob/HDFS-265/src/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java</a></li><li><a href=https://github.com/apache/hadoop-hdfs/blob/trunk/src/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java>https://github.com/apache/hadoop-hdfs/blob/trunk/src/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java</a></li></ul></blockquote><p><strong>Comment by myself (March 2017):</strong></p><blockquote><p>Thanks for the reply!</p><p>This post is over 3 years old - I would rate it quite outdated anyway ;) Nevertheless: Good to have your comment here for clarification. üëç</p></blockquote></div></div><div class="container footer">Morris Jobke - <a rel=license href=http://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a></div></body></html>