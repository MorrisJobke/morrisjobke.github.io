<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><title>Morris Jobke</title><link rel=stylesheet href=/css/pygment_trac.css?1623357001><link rel=alternate type=application/atom+xml title="Atom feed" href=/feed.xml><link rel=stylesheet href=/css/webfonts.css?1623357001><link rel=stylesheet href=/css/base.css?1623357001><meta property="og:title" content="Word Clock - Software"><meta property="og:description" content="Dies ist die Fortsetzung der Anleitung für die Word Clock. Den Hardwareteil habe ich hier beschrieben.
In diesem Beitrag möchte ich auf die Software-Komponente eingehen. Der komplette Quellcode lässt sich auf Github finden und ist unter MIT lizensiert.
Features Ich habe einige Features im Kopf, die ich gerne in der Uhr umgesetzt haben möchte und deshalb hier beschreibe.
 Anzeige der Uhrzeit (Captain Obvious lässt grüßen) automatisches Stellen der Uhrzeit via NTP (ein Protokoll für die Synchronisation der Uhrzeit) über WLAN Zugriff auf das Erscheinungsbild der Uhr über eine API (z."><meta property="og:type" content="article"><meta property="og:url" content="https://morrisjobke.de/2020/03/20/word-clock-software/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-20T18:19:00+00:00"><meta property="article:modified_time" content="2020-03-20T18:19:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Word Clock - Software"><meta name=twitter:description content="Dies ist die Fortsetzung der Anleitung für die Word Clock. Den Hardwareteil habe ich hier beschrieben.
In diesem Beitrag möchte ich auf die Software-Komponente eingehen. Der komplette Quellcode lässt sich auf Github finden und ist unter MIT lizensiert.
Features Ich habe einige Features im Kopf, die ich gerne in der Uhr umgesetzt haben möchte und deshalb hier beschreibe.
 Anzeige der Uhrzeit (Captain Obvious lässt grüßen) automatisches Stellen der Uhrzeit via NTP (ein Protokoll für die Synchronisation der Uhrzeit) über WLAN Zugriff auf das Erscheinungsbild der Uhr über eine API (z."><meta name=twitter:site content="@MorrisJobke"><meta itemprop=name content="Word Clock - Software"><meta itemprop=description content="Dies ist die Fortsetzung der Anleitung für die Word Clock. Den Hardwareteil habe ich hier beschrieben.
In diesem Beitrag möchte ich auf die Software-Komponente eingehen. Der komplette Quellcode lässt sich auf Github finden und ist unter MIT lizensiert.
Features Ich habe einige Features im Kopf, die ich gerne in der Uhr umgesetzt haben möchte und deshalb hier beschreibe.
 Anzeige der Uhrzeit (Captain Obvious lässt grüßen) automatisches Stellen der Uhrzeit via NTP (ein Protokoll für die Synchronisation der Uhrzeit) über WLAN Zugriff auf das Erscheinungsbild der Uhr über eine API (z."><meta itemprop=datePublished content="2020-03-20T18:19:00+00:00"><meta itemprop=dateModified content="2020-03-20T18:19:00+00:00"><meta itemprop=wordCount content="1458"><meta itemprop=keywords content></head><body><div class=header><div class=container><span class=name>Morris<b>Jobke</b></span><ul class=menu><li><a href=/>Articles</a></wli> /<li><a href=/talks>Talks</a></li>/<li><a href=/links>Links</a></li><li class=item-right><a href=/feed.xml><svg width="20" height="20" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M576 1344q0 80-56 136t-136 56-136-56-56-136 56-136 136-56 136 56 56 136zm512 123q2 28-17 48-18 21-47 21H889q-25 0-43-16.5t-20-41.5q-22-229-184.5-391.5T250 902q-25-2-41.5-20T192 839V704q0-29 21-47 17-17 43-17h5q160 13 306 80.5T826 902q114 113 181.5 259t80.5 306zm512 2q2 27-18 47-18 20-46 20h-143q-26 0-44.5-17.5T1329 1476q-12-215-101-408.5t-231.5-336-336-231.5T252 398q-25-1-42.5-19.5T192 335V192q0-28 20-46 18-18 44-18h3q262 13 501.5 120T1186 542q187 186 294 425.5t120 501.5z" fill="#fff"/></svg></a></li><li class=item-right><a href=https://twitter.com/MorrisJobke><svg width="20" height="20" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5T1369.5 1125 1185 1335.5t-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5T285 1033q33 5 61 5 43 0 85-11-112-23-185.5-111.5T172 710v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5T884 653q-8-38-8-74 0-134 94.5-228.5T1199 256q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z" fill="#fff"/></svg></a></li><li class=item-right><a href=https://github.com/MorrisJobke><svg width="20" height="20" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1664 896q0 251-146.5 451.5T1139 1625q-27 5-39.5-7t-12.5-30v-211q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 89t.5 54q0 18-13 30t-40 7q-232-77-378.5-277.5T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z" fill="#fff"/></svg></a></li></ul></div></div><div class=container><h1>Word Clock - Software <span class=meta>20 Mar 2020</span></h1><div id=post><p>Dies ist die Fortsetzung der Anleitung für die Word Clock. Den Hardwareteil habe ich <a href=/2020/03/19/word-clock-hardware/>hier</a> beschrieben.</p><p>In diesem Beitrag möchte ich auf die Software-Komponente eingehen. Der komplette Quellcode lässt sich auf <a href=https://github.com/morrisJobke/clock>Github</a> finden und ist unter MIT lizensiert.</p><h2 id=features>Features</h2><p>Ich habe einige Features im Kopf, die ich gerne in der Uhr umgesetzt haben möchte und deshalb hier beschreibe.</p><ul><li>Anzeige der Uhrzeit (Captain Obvious lässt grüßen)</li><li>automatisches Stellen der Uhrzeit via <a href=https://de.wikipedia.org/wiki/Network_Time_Protocol>NTP</a> (ein Protokoll für die Synchronisation der Uhrzeit) über WLAN</li><li>Zugriff auf das Erscheinungsbild der Uhr über eine API (z.B. Umstellen des Farbmusters, Helligkeit, &mldr;) - damit die Uhr auf äußere Einflüsse reagieren kann und sich in die Wohnung integriert</li><li>den aktuellen CO2 Wert meiner Netatmo Wetterstation als Farbe auf der Uhr darstellen (grün -> gelb -> rot)</li><li>die Helligkeit automatisch einstellen - hier benutze ich einen Helligkeitssensor, der in einem anderen Gerät verbaut ist. Das Gerät ist eine <a href="https://awtrixdocs.blueforcer.de/#/de-de/hardware?id=lichtsensor-zur-helligkeitsregelung-optional">AWTRIX</a>, die diesen Wert über eine MQTT-API (siehe &ldquo;Bibliotheken&rdquo;, für die Erklärung, was das ist) übermittelt.</li></ul><h2 id=open-source-sei-dank>Open Source sei Dank</h2><p>Da es eine große Open Source Community rund um den Mikrocontroller gibt, wollte ich so wenig wie möglich selbst bauen und auf bestehende Komponenten zurückgreifen. Folgende Bibliotheken und Werkzeuge habe ich genutzt:</p><h3 id=ide>IDE</h3><p><a href=https://www.arduino.cc/en/Main/Software>Arduino IDE</a> - dies ist die Entwicklungsumgebung, in der programmiert wird und anschließend das Programm auf den Mikrocontroller übertragen wird. Einsteigerfreundlich und recht einfach gehalten. Wer mehr möchte, sei auf <a href=https://platformio.org>PlatformIO</a> verwiesen. Sämtliche unten genannten Bibliotheken habe ich über die Arduino IDE installiert und aktualisiert. Dazu auf &ldquo;Werkzeuge&rdquo; > &ldquo;Bibliotheken verwalten&rdquo; gehen, nach der Bibliothek suchen und auf &ldquo;Installieren&rdquo; klicken. Schon kann diese genutzt werden.</p><h3 id=unterstützung-für-den-esp8266-nachrüsten>Unterstützung für den ESP8266 nachrüsten</h3><p>Von Haus aus kann die Arduino IDE nicht mit dem ESP8266 umgehen. Dazu müssen Informationen zum Mikrocontroller nachgeladen werden. Dies erledigt man, indem man unter &ldquo;Einstellungen&rdquo; > &ldquo;Zusätzliche Boardverwalter-URL&rdquo; <code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code> einträgt. Nun kann man unter &ldquo;Werkzeuge&rdquo; > &ldquo;Board&rdquo; > &ldquo;Boardverwalter&rdquo; nach &ldquo;NodeMCU&rdquo; suchen. Hier muss man nun das gefundene Paket &ldquo;esp8266&rdquo; installieren. Ist dies geschehen, kann man unter &ldquo;Werkzeuge&rdquo; > &ldquo;Board&rdquo; > &ldquo;NodeMCU 1.0&rdquo; auswählen und die Arduino IDE ist bereit das Programm an den Mikrocontroller zu übertragen. Der Bequemlichkeit halber würde ich noch empfehlen den &ldquo;Upload Speed&rdquo; unter &ldquo;Werkzeuge&rdquo; höher zu setzen, um bei der Übertragung nicht zu lange warten zu müssen. <code>921.600</code> hat bei mir super funktioniert.</p><h3 id=bibliotheken>Bibliotheken</h3><p>Für die einzelnen Funktionen habe ich auf einige Bibliotheken zurück gegriffen, die ich einmal kurz vorstellen möchte.</p><ul><li><p><a href=http://fastled.io>FastLED</a> - dies ist die wichtigste. Sie übernimmt die komfortable Steuerung der LEDs. Man kann damit angeben, was genau eingesetzt wird - unter anderen zum Beispiel der LED-Controller, die Anzahl an LEDs, die Anordnung dieser (Streifen, Matrix, &mldr;) oder die allgemeine Helligkeit. Anschließend hat man ein definiertes Interface, um die LEDs anzusteuern und gewisse Farben, Muster, Farbverläufe in einer gewissen Taktung zu erzeugen. Unter &ldquo;Datei&rdquo; > &ldquo;Beispiele&rdquo; > &ldquo;FastLED&rdquo; findet man auch zahlreiche fertige Code-Stückchen, die man direkt ausprobieren kann. ColorPalette ist ein schönes Beispiel und nutze ich gerne. Hier muss man nur <code>LED_PIN</code> auf &ldquo;2&rdquo; ändern, wenn man die Schaltung aus meinem Hardware-Beitrag genommen hat und gibt die Anzahl angeschlossener LEDs unter <code>NUM_LEDS</code> an und schon leuchten die LEDs nach der erfolgreichen Übertragung auf den Mikrocontroller (das wird über den Pfeil nach rechts in der Titelleiste angestoßen - vorher natürlich den Mikrocontroller per USB anstecken - alles weitere findet die Arduino IDE eigentlich selbstständig).</p></li><li><p><a href=https://github.com/plapointe6/EspMQTTClient>EspMQTTClient</a> - diese Bibliothek verbindet zwei meiner Ansprüche - das Verbinden zu einem WLAN und eine API. Die API sollte etwas leichtgewichtiges sein und deshalb setze ich hier auf <a href=https://de.wikipedia.org/wiki/MQTT>MQTT</a>. Dies ist ein Protokoll für das Publish-Subscribe-Pattern. Man kann Nachrichten an einen gewissen Kanal schicken und man kann Nachrichten auf einem gewissen Kanal empfangen. Dazu verbinden sich Sender und Empfänger gegen einen gemeinsamen MQTT-Server und dann können diese Nachrichten untereinander austauschen. Die Bibliothek bietet mir an WLAN Zugangsdaten und einen MQTT-Server zu hinterlegen und dann kümmert sie sich darum, dass die Verbindung bestehen bleibt. Anschließend kann ich auf Kanälen (Topics werden diese in MQTT genannt) hören, ob Nachrichten eintreffen und bei jeder eingehenden Nachricht eine Funktion ausführen, die darauf reagiert. Zum Beispiel auf einem Kanal, denn ich &ldquo;clock/brightness&rdquo; genannt habe, kann man einen Zahlenwert von 0 bis 255 schicken und die Uhr reagiert darauf, indem es via FastLED <code>FastLED.setBrightness(...);</code> diesen einstellt. Konkret sieht das <a href=https://github.com/MorrisJobke/clock/blob/c442c6784fcef633e06d05363c3c581aa10995c9/clock.ino#L106-L113>so aus</a>. Zusätzlich nutzt diese Bibliothek noch <a href=https://pubsubclient.knolleary.net>PubSubClient</a>, der auch über &ldquo;Bibliotheken installieren&rdquo; installiert werden muss.</p></li><li><p><a href=https://github.com/arduino-libraries/NTPClient>NTPClient</a> - wie der Name schon verrät ist dies die Bibliothek, die darauf achtet, dass die im Mikrocontroller eingebaute Uhr mit der eigentlich Uhrzeit synchronisiert ist. Dazu benötigt es ausschließlich Internetzugang (das macht ja EspMQTTClient für mich) und dann war es das auch schon.</p></li><li><p><a href=https://arduinojson.org>ArduinoJSON</a> - diese Bibliothek brauche ich, um <a href=https://de.wikipedia.org/wiki/JavaScript_Object_Notation>JSON</a> - ein Datenformat - zu lesen. Das Datenformat wird von AWTRIX benutzt, um Daten in MQTT zu übermitteln. Diese Daten enthalten den Helligkeitswert, den der Sensor in der AWTRIX misst. Damit konnte ich mir sparen einen Helligkeitssensor in die Uhr einzubauen. Natürlich kann man den auch direkt einbauen und dann auslesen und spart sich den Umweg über MQTT und hat das ganze autark. Falls dies gewünscht ist, kann man den Sensor genau wie in der <a href="https://awtrixdocs.blueforcer.de/#/de-de/hardware?id=lichtsensor-zur-helligkeitsregelung-optional">AWTRIX-Anleitung</a> einbauen, da ich die exakt gleiche Schaltung verwende.</p></li></ul><h3 id=fallstricke>Fallstricke</h3><p>Es gibt noch zwei Fallstricke, die es zu beachten gibt. Einerseits bin ich anfangs über folgenden Fehler in FastLED gestolpert:</p><pre><code>error: 'boolean' has a previous declaration as 'typedef bool boolean'
 typedef bool boolean;
              ^
</code></pre><p>Diesen habe ich behoben, indem in die FastLED Bibliothek entsprechend angepasst habe. Die heruntergeladenen Bibliotheken finden sich normalerweise im &ldquo;Dokumente/Arduino/libraries&rdquo; Ordner des aktuellen Nutzers. Dort musste ich die Zeile 15 in <code>FastLED/platforms/esp/8266/led_sysdefs_esp8266.h</code> auskommentieren. Diese Zeile enthält <code>typedef uint8_t boolean;</code>. Danach war der Fehler gelöst. Das ganze habe ich <a href=https://github.com/FastLED/FastLED/issues/733#issuecomment-491634606>hier</a> gefunden.</p><p>Ein zweiter Fallstrick ist, dass &ldquo;EspMQTTClient&rdquo; standardmäßig nur Nachrichten bis zu einer Länge von 128 Bytes empfängt. Die Nachrichten von der AWTRIX sind jedoch meistens um die 200 Bytes lang. Um das zu lösen muss der Wert von 128 auf 250 gesetzt werden. Man findet das unter <code>PubSubClient/src/PubSubClient.h</code> als <code>MQTT_MAX_PACKET_SIZE</code>. Sobald der Wert geändert ist, kommen Nachrichten bis zu einer Länge von 250 Bytes an.</p><h2 id=aktuelle-limitierungen>Aktuelle Limitierungen</h2><p>Aktuell gibt es noch 2 Limitierungen des Programms. Die Sommerzeitumstellung ist noch nicht implementiert. Das heißt, man muss die Uhr via API umstellen. Die zweite ist, dass der AWTRIX Teil noch fest eingebaut ist. Man kann diesen aus dem Quellcode löschen, indem man nach <code>// TODO only include if AWTRIX is enabled</code> sucht und die folgenden Zeilen löscht.</p><h2 id=konfiguration>Konfiguration</h2><p>Um Einstellungen vorzunehmen, gibt es eine Datei, die persönliche Einstellungen enthält und damit die Uhr an die eigenen Bedürfnisse anpasst. Hierzu einfach die Datei <code>config.h.dist</code> nach <code>config.h</code> kopieren und die entsprechenden Werte ändern. Dies sind unter anderen WLAN-Name und Passwort oder die IP des MQTT-Servers. Ebenso können die MQTT-Topic-Namen geändert werden.</p><h2 id=api>API</h2><p>Die Uhr hat eine auf MQTT basierende API. Das heißt, sie verbindet sich zu einem konfigurierten MQTT-Server und lauscht dort auf gewissen Kanälen (Topics). Vom eigenen Rechner aus, kann man sich ebenfalls mit diesem Server verbinden und dann mit der Uhr interagieren. Dazu nach MQTT Client suchen - ich nutze unter macOS <a href=http://workswithweb.com/mqttbox.html>MQTT Box</a>, der auf allen Platformen läuft. Aber es gibt auch andere Clients. Der MQTT-Server selbst läuft bei mir hier auf einem Server zuhause - das ist die Software mosqitto, aber es gibt viele verschiedene <a href=https://github.com/mqtt/mqtt.github.io/wiki/brokers>MQTT-Server</a>, die alle das gleiche Protokoll sprechen.</p><p>Die genauen Namen der MQTT-Topics können über die Variablen in <code>config.h</code> angegeben werden.</p><h3 id=farbschema>Farbschema</h3><ul><li><code>MQTT_SUBSCRIBE_COLOR_PPM_TOPIC</code>: hier kann eine Ganzzahl hingeschickt werden und die Uhr wird ihr Farbschema je nach Wert anpassen. Diese entsprechen den Grenzwerten für gute, mittlere, mäßige und schlechte Luftqualität und sind bei 800, 1000 und 1400. Dafür nutzt es dann entweder lila, blau, grün-gelb oder rote Farben für die Uhr. Falls irgendwann etwas hier hin geschickt wird, bleibt die Uhr auf diesem Farbschema, bis ein neuer Wert geschickt wird, die Uhr neu gestartet wird oder etwas zu <code>MQTT_SUBSCRIBE_COLOR_RAINBOW_TOPIC</code> geschickt wird.</li><li><code>MQTT_SUBSCRIBE_COLOR_RAINBOW_TOPIC</code>: hier kann etwas beliebiges hingeschickt werden und die Uhr wird sich auf das Regenbogen-Farbschema zurück stellen.</li></ul><h3 id=uhrmodus-und-alle-leds-aktivieren>Uhrmodus und Alle LEDs aktivieren</h3><ul><li><code>MQTT_SUBSCRIBE_VIEW_FULL_TOPIC</code>: wenn etwas hier hin geschickt wird, werden alle LEDs der Uhr angesteuert und nicht nur die, der aktuellen Uhrzeit</li><li><code>MQTT_SUBSCRIBE_VIEW_TIME_TOPIC</code>: wenn etwas hier hin geschickt wird, werden wieder nur die LEDs angesteuert, die die aktuelle Uhrzeit repräsentieren</li></ul><h3 id=helligkeit>Helligkeit</h3><ul><li><code>MQTT_SUBSCRIBE_BRIGHTNESS_TOPIC</code>: hier kann ein Wert zwischen 0 (LEDs aus) und 255 (volle Helligkeit) geschickt werden und die Uhr setzt das um</li></ul><h3 id=zeitverschiebung>Zeitverschiebung</h3><ul><li><code>MQTT_SUBSCRIBE_OFFSET_TOPIC</code>: hier kann eine Zeitverschiebung in Sekunden geschickt werden, die die Verschiebung zur UTC-Zeit (das ist GMT in der Normalzeit) angibt. Für Deutschland müsste man im Winter 3600 und im Sommer 7200 setzen. (siehe Limitierungen oben - die Uhr kann noch nicht automatisch zwischen Sommer- und Winterzeit wechseln)</li></ul><p>Das wäre es dann. Viel Spaß beim Ausprobieren und lasst mich wissen, falls ihr Fragen habt. :)</p></div></div><div class="container footer">Morris Jobke - <a rel=license href=http://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a></div></body></html>